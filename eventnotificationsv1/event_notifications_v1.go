/**
 * (C) Copyright IBM Corp. 2022.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.43.4-432d779b-20220119-173927
 */

// Package eventnotificationsv1 : Operations and models for the EventNotificationsV1 service
package eventnotificationsv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	common "github.com/IBM/event-notifications-go-admin-sdk/common"
	"github.com/IBM/go-sdk-core/v5/core"
	"github.com/go-openapi/strfmt"
)

// EventNotificationsV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// API Version: 1.0
type EventNotificationsV1 struct {
	Service *core.BaseService
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://us-south.event-notifications.cloud.ibm.com/event-notifications"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "event_notifications"

// EventNotificationsV1Options : Service options
type EventNotificationsV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewEventNotificationsV1UsingExternalConfig : constructs an instance of EventNotificationsV1 with passed in options and external configuration.
func NewEventNotificationsV1UsingExternalConfig(options *EventNotificationsV1Options) (eventNotifications *EventNotificationsV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	eventNotifications, err = NewEventNotificationsV1(options)
	if err != nil {
		return
	}

	err = eventNotifications.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = eventNotifications.Service.SetServiceURL(options.URL)
	}
	return
}

// NewEventNotificationsV1 : constructs an instance of EventNotificationsV1 with passed in options.
func NewEventNotificationsV1(options *EventNotificationsV1Options) (service *EventNotificationsV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &EventNotificationsV1{
		Service: baseService,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "eventNotifications" suitable for processing requests.
func (eventNotifications *EventNotificationsV1) Clone() *EventNotificationsV1 {
	if core.IsNil(eventNotifications) {
		return nil
	}
	clone := *eventNotifications
	clone.Service = eventNotifications.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (eventNotifications *EventNotificationsV1) SetServiceURL(url string) error {
	return eventNotifications.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (eventNotifications *EventNotificationsV1) GetServiceURL() string {
	return eventNotifications.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (eventNotifications *EventNotificationsV1) SetDefaultHeaders(headers http.Header) {
	eventNotifications.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (eventNotifications *EventNotificationsV1) SetEnableGzipCompression(enableGzip bool) {
	eventNotifications.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (eventNotifications *EventNotificationsV1) GetEnableGzipCompression() bool {
	return eventNotifications.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (eventNotifications *EventNotificationsV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	eventNotifications.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (eventNotifications *EventNotificationsV1) DisableRetries() {
	eventNotifications.Service.DisableRetries()
}

// SendNotifications : Send a notification
// Send a notification.
func (eventNotifications *EventNotificationsV1) SendNotifications(sendNotificationsOptions *SendNotificationsOptions) (result *NotificationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.SendNotificationsWithContext(context.Background(), sendNotificationsOptions)
}

// SendNotificationsWithContext is an alternate form of the SendNotifications method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) SendNotificationsWithContext(ctx context.Context, sendNotificationsOptions *SendNotificationsOptions) (result *NotificationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(sendNotificationsOptions, "sendNotificationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(sendNotificationsOptions, "sendNotificationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *sendNotificationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/notifications`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range sendNotificationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "SendNotifications")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if sendNotificationsOptions.Subject != nil {
		body["subject"] = sendNotificationsOptions.Subject
	}
	if sendNotificationsOptions.Severity != nil {
		body["severity"] = sendNotificationsOptions.Severity
	}
	if sendNotificationsOptions.ID != nil {
		body["id"] = sendNotificationsOptions.ID
	}
	if sendNotificationsOptions.Source != nil {
		body["source"] = sendNotificationsOptions.Source
	}
	if sendNotificationsOptions.EnSourceID != nil {
		body["en_source_id"] = sendNotificationsOptions.EnSourceID
	}
	if sendNotificationsOptions.Type != nil {
		body["type"] = sendNotificationsOptions.Type
	}
	if sendNotificationsOptions.Time != nil {
		body["time"] = sendNotificationsOptions.Time
	}
	body["data"] = make(map[string]interface{})
	if sendNotificationsOptions.Data != nil {
		body["data"] = sendNotificationsOptions.Data
	}
	if sendNotificationsOptions.PushTo != nil {
		pushToJson, _ := json.Marshal(sendNotificationsOptions.PushTo)
		body["push_to"] = string(pushToJson)
	}
	if sendNotificationsOptions.MessageFcmBody != nil {
		pushBodyJson, _ := json.Marshal(sendNotificationsOptions.MessageFcmBody)
		body["message_fcm_body"] = string(pushBodyJson)
	}
	body["datacontenttype"] = "application/json"
	if sendNotificationsOptions.Datacontenttype != nil {
		body["datacontenttype"] = sendNotificationsOptions.Datacontenttype
	}
	body["specversion"] = "1.0"
	if sendNotificationsOptions.Specversion != nil {
		body["specversion"] = sendNotificationsOptions.Specversion
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNotificationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSources : List all Sources
// List all Sources.
func (eventNotifications *EventNotificationsV1) ListSources(listSourcesOptions *ListSourcesOptions) (result *SourceList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListSourcesWithContext(context.Background(), listSourcesOptions)
}

// ListSourcesWithContext is an alternate form of the ListSources method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListSourcesWithContext(ctx context.Context, listSourcesOptions *ListSourcesOptions) (result *SourceList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSourcesOptions, "listSourcesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSourcesOptions, "listSourcesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listSourcesOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSourcesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListSources")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listSourcesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSourcesOptions.Limit))
	}
	if listSourcesOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listSourcesOptions.Offset))
	}
	if listSourcesOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listSourcesOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSourceList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSource : Get a Source
// Get a Sources.
func (eventNotifications *EventNotificationsV1) GetSource(getSourceOptions *GetSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSourceWithContext(context.Background(), getSourceOptions)
}

// GetSourceWithContext is an alternate form of the GetSource method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSourceWithContext(ctx context.Context, getSourceOptions *GetSourceOptions) (result *Source, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSourceOptions, "getSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSourceOptions, "getSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSourceOptions.InstanceID,
		"id":          *getSourceOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/sources/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTopic : Create a new Topic
// Create a new Topic.
func (eventNotifications *EventNotificationsV1) CreateTopic(createTopicOptions *CreateTopicOptions) (result *TopicResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateTopicWithContext(context.Background(), createTopicOptions)
}

// CreateTopicWithContext is an alternate form of the CreateTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateTopicWithContext(ctx context.Context, createTopicOptions *CreateTopicOptions) (result *TopicResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTopicOptions, "createTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTopicOptions, "createTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createTopicOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createTopicOptions.Name != nil {
		body["name"] = createTopicOptions.Name
	}
	if createTopicOptions.Description != nil {
		body["description"] = createTopicOptions.Description
	}
	if createTopicOptions.Sources != nil {
		body["sources"] = createTopicOptions.Sources
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopicResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTopics : List all Topics
// List all Topics.
func (eventNotifications *EventNotificationsV1) ListTopics(listTopicsOptions *ListTopicsOptions) (result *TopicList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListTopicsWithContext(context.Background(), listTopicsOptions)
}

// ListTopicsWithContext is an alternate form of the ListTopics method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListTopicsWithContext(ctx context.Context, listTopicsOptions *ListTopicsOptions) (result *TopicList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTopicsOptions, "listTopicsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTopicsOptions, "listTopicsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listTopicsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTopicsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListTopics")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listTopicsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTopicsOptions.Limit))
	}
	if listTopicsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listTopicsOptions.Offset))
	}
	if listTopicsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listTopicsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopicList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetTopic : Get details of a Topic
// Get details of a Topic.
func (eventNotifications *EventNotificationsV1) GetTopic(getTopicOptions *GetTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	return eventNotifications.GetTopicWithContext(context.Background(), getTopicOptions)
}

// GetTopicWithContext is an alternate form of the GetTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetTopicWithContext(ctx context.Context, getTopicOptions *GetTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTopicOptions, "getTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTopicOptions, "getTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getTopicOptions.InstanceID,
		"id":          *getTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if getTopicOptions.Include != nil {
		builder.AddQuery("include", fmt.Sprint(*getTopicOptions.Include))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopic)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ReplaceTopic : Update details of a Topic
// Update details of a Topic.
func (eventNotifications *EventNotificationsV1) ReplaceTopic(replaceTopicOptions *ReplaceTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	return eventNotifications.ReplaceTopicWithContext(context.Background(), replaceTopicOptions)
}

// ReplaceTopicWithContext is an alternate form of the ReplaceTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ReplaceTopicWithContext(ctx context.Context, replaceTopicOptions *ReplaceTopicOptions) (result *Topic, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceTopicOptions, "replaceTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceTopicOptions, "replaceTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *replaceTopicOptions.InstanceID,
		"id":          *replaceTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ReplaceTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if replaceTopicOptions.Name != nil {
		body["name"] = replaceTopicOptions.Name
	}
	if replaceTopicOptions.Description != nil {
		body["description"] = replaceTopicOptions.Description
	}
	if replaceTopicOptions.Sources != nil {
		body["sources"] = replaceTopicOptions.Sources
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTopic)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTopic : Delete a Topic
// Delete a Topic.
func (eventNotifications *EventNotificationsV1) DeleteTopic(deleteTopicOptions *DeleteTopicOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteTopicWithContext(context.Background(), deleteTopicOptions)
}

// DeleteTopicWithContext is an alternate form of the DeleteTopic method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteTopicWithContext(ctx context.Context, deleteTopicOptions *DeleteTopicOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTopicOptions, "deleteTopicOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTopicOptions, "deleteTopicOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteTopicOptions.InstanceID,
		"id":          *deleteTopicOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/topics/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTopicOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteTopic")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// CreateDestination : Create a new Destination
// Create a new Destination.
func (eventNotifications *EventNotificationsV1) CreateDestination(createDestinationOptions *CreateDestinationOptions) (result *DestinationResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateDestinationWithContext(context.Background(), createDestinationOptions)
}

// CreateDestinationWithContext is an alternate form of the CreateDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateDestinationWithContext(ctx context.Context, createDestinationOptions *CreateDestinationOptions) (result *DestinationResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createDestinationOptions, "createDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createDestinationOptions, "createDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createDestinationOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createDestinationOptions.Name != nil {
		body["name"] = createDestinationOptions.Name
	}
	if createDestinationOptions.Type != nil {
		body["type"] = createDestinationOptions.Type
	}
	if createDestinationOptions.Description != nil {
		body["description"] = createDestinationOptions.Description
	}
	if createDestinationOptions.Config != nil {
		body["config"] = createDestinationOptions.Config
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListDestinations : List all Destinations
// List all Destinations.
func (eventNotifications *EventNotificationsV1) ListDestinations(listDestinationsOptions *ListDestinationsOptions) (result *DestinationList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListDestinationsWithContext(context.Background(), listDestinationsOptions)
}

// ListDestinationsWithContext is an alternate form of the ListDestinations method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListDestinationsWithContext(ctx context.Context, listDestinationsOptions *ListDestinationsOptions) (result *DestinationList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listDestinationsOptions, "listDestinationsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listDestinationsOptions, "listDestinationsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listDestinationsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDestinationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListDestinations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listDestinationsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDestinationsOptions.Limit))
	}
	if listDestinationsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listDestinationsOptions.Offset))
	}
	if listDestinationsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listDestinationsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetDestination : Get details of a Destination
// Get details of a Destination.
func (eventNotifications *EventNotificationsV1) GetDestination(getDestinationOptions *GetDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	return eventNotifications.GetDestinationWithContext(context.Background(), getDestinationOptions)
}

// GetDestinationWithContext is an alternate form of the GetDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetDestinationWithContext(ctx context.Context, getDestinationOptions *GetDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDestinationOptions, "getDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDestinationOptions, "getDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getDestinationOptions.InstanceID,
		"id":          *getDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestination)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// UpdateDestination : Update details of a Destination
// Update details of a Destination.
func (eventNotifications *EventNotificationsV1) UpdateDestination(updateDestinationOptions *UpdateDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateDestinationWithContext(context.Background(), updateDestinationOptions)
}

// UpdateDestinationWithContext is an alternate form of the UpdateDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateDestinationWithContext(ctx context.Context, updateDestinationOptions *UpdateDestinationOptions) (result *Destination, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateDestinationOptions, "updateDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateDestinationOptions, "updateDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateDestinationOptions.InstanceID,
		"id":          *updateDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateDestinationOptions.Name != nil {
		body["name"] = updateDestinationOptions.Name
	}
	if updateDestinationOptions.Description != nil {
		body["description"] = updateDestinationOptions.Description
	}
	if updateDestinationOptions.Config != nil {
		body["config"] = updateDestinationOptions.Config
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestination)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteDestination : Delete a Destination
// Delete a Destination.
func (eventNotifications *EventNotificationsV1) DeleteDestination(deleteDestinationOptions *DeleteDestinationOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteDestinationWithContext(context.Background(), deleteDestinationOptions)
}

// DeleteDestinationWithContext is an alternate form of the DeleteDestination method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteDestinationWithContext(ctx context.Context, deleteDestinationOptions *DeleteDestinationOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteDestinationOptions, "deleteDestinationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteDestinationOptions, "deleteDestinationOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteDestinationOptions.InstanceID,
		"id":          *deleteDestinationOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteDestinationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteDestination")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// ListDestinationDevices : Get list of Destination devices
// Get list of Destination devices.
func (eventNotifications *EventNotificationsV1) ListDestinationDevices(listDestinationDevicesOptions *ListDestinationDevicesOptions) (result *DestinationDevicesList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListDestinationDevicesWithContext(context.Background(), listDestinationDevicesOptions)
}

// ListDestinationDevicesWithContext is an alternate form of the ListDestinationDevices method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListDestinationDevicesWithContext(ctx context.Context, listDestinationDevicesOptions *ListDestinationDevicesOptions) (result *DestinationDevicesList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listDestinationDevicesOptions, "listDestinationDevicesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listDestinationDevicesOptions, "listDestinationDevicesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listDestinationDevicesOptions.InstanceID,
		"id":          *listDestinationDevicesOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/devices`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listDestinationDevicesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListDestinationDevices")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listDestinationDevicesOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listDestinationDevicesOptions.Limit))
	}
	if listDestinationDevicesOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listDestinationDevicesOptions.Offset))
	}
	if listDestinationDevicesOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listDestinationDevicesOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationDevicesList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetDestinationDevicesReport : Retrieves report of destination devices registered
// Retrieves report of destination devices registered.
func (eventNotifications *EventNotificationsV1) GetDestinationDevicesReport(getDestinationDevicesReportOptions *GetDestinationDevicesReportOptions) (result *DestinationDevicesReport, response *core.DetailedResponse, err error) {
	return eventNotifications.GetDestinationDevicesReportWithContext(context.Background(), getDestinationDevicesReportOptions)
}

// GetDestinationDevicesReportWithContext is an alternate form of the GetDestinationDevicesReport method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetDestinationDevicesReportWithContext(ctx context.Context, getDestinationDevicesReportOptions *GetDestinationDevicesReportOptions) (result *DestinationDevicesReport, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDestinationDevicesReportOptions, "getDestinationDevicesReportOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDestinationDevicesReportOptions, "getDestinationDevicesReportOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getDestinationDevicesReportOptions.InstanceID,
		"id":          *getDestinationDevicesReportOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/devices/report`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDestinationDevicesReportOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetDestinationDevicesReport")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if getDestinationDevicesReportOptions.Days != nil {
		builder.AddQuery("days", fmt.Sprint(*getDestinationDevicesReportOptions.Days))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationDevicesReport)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTagsSubscriptionsDevice : List all Tag Subscriptions for a device
// List all Tag Subscriptions for a device.
func (eventNotifications *EventNotificationsV1) ListTagsSubscriptionsDevice(listTagsSubscriptionsDeviceOptions *ListTagsSubscriptionsDeviceOptions) (result *TagsSubscriptionList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListTagsSubscriptionsDeviceWithContext(context.Background(), listTagsSubscriptionsDeviceOptions)
}

// ListTagsSubscriptionsDeviceWithContext is an alternate form of the ListTagsSubscriptionsDevice method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListTagsSubscriptionsDeviceWithContext(ctx context.Context, listTagsSubscriptionsDeviceOptions *ListTagsSubscriptionsDeviceOptions) (result *TagsSubscriptionList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTagsSubscriptionsDeviceOptions, "listTagsSubscriptionsDeviceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTagsSubscriptionsDeviceOptions, "listTagsSubscriptionsDeviceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listTagsSubscriptionsDeviceOptions.InstanceID,
		"id":          *listTagsSubscriptionsDeviceOptions.ID,
		"device_id":   *listTagsSubscriptionsDeviceOptions.DeviceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions/devices/{device_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTagsSubscriptionsDeviceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListTagsSubscriptionsDevice")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listTagsSubscriptionsDeviceOptions.TagName != nil {
		builder.AddQuery("tag_name", fmt.Sprint(*listTagsSubscriptionsDeviceOptions.TagName))
	}
	if listTagsSubscriptionsDeviceOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTagsSubscriptionsDeviceOptions.Limit))
	}
	if listTagsSubscriptionsDeviceOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listTagsSubscriptionsDeviceOptions.Offset))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTagsSubscriptionList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListTagsSubscription : List all Tag Subscriptions
// List all Tag Subscriptions.
func (eventNotifications *EventNotificationsV1) ListTagsSubscription(listTagsSubscriptionOptions *ListTagsSubscriptionOptions) (result *TagsSubscriptionList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListTagsSubscriptionWithContext(context.Background(), listTagsSubscriptionOptions)
}

// ListTagsSubscriptionWithContext is an alternate form of the ListTagsSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListTagsSubscriptionWithContext(ctx context.Context, listTagsSubscriptionOptions *ListTagsSubscriptionOptions) (result *TagsSubscriptionList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listTagsSubscriptionOptions, "listTagsSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listTagsSubscriptionOptions, "listTagsSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listTagsSubscriptionOptions.InstanceID,
		"id":          *listTagsSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listTagsSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListTagsSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listTagsSubscriptionOptions.DeviceID != nil {
		builder.AddQuery("device_id", fmt.Sprint(*listTagsSubscriptionOptions.DeviceID))
	}
	if listTagsSubscriptionOptions.UserID != nil {
		builder.AddQuery("user_id", fmt.Sprint(*listTagsSubscriptionOptions.UserID))
	}
	if listTagsSubscriptionOptions.TagName != nil {
		builder.AddQuery("tag_name", fmt.Sprint(*listTagsSubscriptionOptions.TagName))
	}
	if listTagsSubscriptionOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listTagsSubscriptionOptions.Limit))
	}
	if listTagsSubscriptionOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listTagsSubscriptionOptions.Offset))
	}
	if listTagsSubscriptionOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listTagsSubscriptionOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTagsSubscriptionList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTagsSubscription : Create a new Tag subscription
// Create a new Tag subscription.
func (eventNotifications *EventNotificationsV1) CreateTagsSubscription(createTagsSubscriptionOptions *CreateTagsSubscriptionOptions) (result *DestinationTagsSubscriptionResponse, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateTagsSubscriptionWithContext(context.Background(), createTagsSubscriptionOptions)
}

// CreateTagsSubscriptionWithContext is an alternate form of the CreateTagsSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateTagsSubscriptionWithContext(ctx context.Context, createTagsSubscriptionOptions *CreateTagsSubscriptionOptions) (result *DestinationTagsSubscriptionResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTagsSubscriptionOptions, "createTagsSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTagsSubscriptionOptions, "createTagsSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createTagsSubscriptionOptions.InstanceID,
		"id":          *createTagsSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTagsSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateTagsSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createTagsSubscriptionOptions.DeviceID != nil {
		body["device_id"] = createTagsSubscriptionOptions.DeviceID
	}
	if createTagsSubscriptionOptions.TagName != nil {
		body["tag_name"] = createTagsSubscriptionOptions.TagName
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDestinationTagsSubscriptionResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteTagsSubscription : Delete a Tag subcription
// Delete a Tag subcription.
func (eventNotifications *EventNotificationsV1) DeleteTagsSubscription(deleteTagsSubscriptionOptions *DeleteTagsSubscriptionOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteTagsSubscriptionWithContext(context.Background(), deleteTagsSubscriptionOptions)
}

// DeleteTagsSubscriptionWithContext is an alternate form of the DeleteTagsSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteTagsSubscriptionWithContext(ctx context.Context, deleteTagsSubscriptionOptions *DeleteTagsSubscriptionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteTagsSubscriptionOptions, "deleteTagsSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteTagsSubscriptionOptions, "deleteTagsSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteTagsSubscriptionOptions.InstanceID,
		"id":          *deleteTagsSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/destinations/{id}/tag_subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteTagsSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteTagsSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	if deleteTagsSubscriptionOptions.DeviceID != nil {
		builder.AddQuery("device_id", fmt.Sprint(*deleteTagsSubscriptionOptions.DeviceID))
	}
	if deleteTagsSubscriptionOptions.TagName != nil {
		builder.AddQuery("tag_name", fmt.Sprint(*deleteTagsSubscriptionOptions.TagName))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// CreateSubscription : Create a new Subscription
// Create a new Subscription.
func (eventNotifications *EventNotificationsV1) CreateSubscription(createSubscriptionOptions *CreateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.CreateSubscriptionWithContext(context.Background(), createSubscriptionOptions)
}

// CreateSubscriptionWithContext is an alternate form of the CreateSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) CreateSubscriptionWithContext(ctx context.Context, createSubscriptionOptions *CreateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSubscriptionOptions, "createSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSubscriptionOptions, "createSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *createSubscriptionOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "CreateSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSubscriptionOptions.Name != nil {
		body["name"] = createSubscriptionOptions.Name
	}
	if createSubscriptionOptions.DestinationID != nil {
		body["destination_id"] = createSubscriptionOptions.DestinationID
	}
	if createSubscriptionOptions.TopicID != nil {
		body["topic_id"] = createSubscriptionOptions.TopicID
	}
	if createSubscriptionOptions.Description != nil {
		body["description"] = createSubscriptionOptions.Description
	}
	if createSubscriptionOptions.Attributes != nil {
		body["attributes"] = createSubscriptionOptions.Attributes
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListSubscriptions : List all Subscriptions
// List all Subscriptions.
func (eventNotifications *EventNotificationsV1) ListSubscriptions(listSubscriptionsOptions *ListSubscriptionsOptions) (result *SubscriptionList, response *core.DetailedResponse, err error) {
	return eventNotifications.ListSubscriptionsWithContext(context.Background(), listSubscriptionsOptions)
}

// ListSubscriptionsWithContext is an alternate form of the ListSubscriptions method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) ListSubscriptionsWithContext(ctx context.Context, listSubscriptionsOptions *ListSubscriptionsOptions) (result *SubscriptionList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSubscriptionsOptions, "listSubscriptionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSubscriptionsOptions, "listSubscriptionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *listSubscriptionsOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSubscriptionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "ListSubscriptions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if listSubscriptionsOptions.Offset != nil {
		builder.AddQuery("offset", fmt.Sprint(*listSubscriptionsOptions.Offset))
	}
	if listSubscriptionsOptions.Limit != nil {
		builder.AddQuery("limit", fmt.Sprint(*listSubscriptionsOptions.Limit))
	}
	if listSubscriptionsOptions.Search != nil {
		builder.AddQuery("search", fmt.Sprint(*listSubscriptionsOptions.Search))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscriptionList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetSubscription : Get details of a Subscription
// Get details of a Subscription.
func (eventNotifications *EventNotificationsV1) GetSubscription(getSubscriptionOptions *GetSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.GetSubscriptionWithContext(context.Background(), getSubscriptionOptions)
}

// GetSubscriptionWithContext is an alternate form of the GetSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) GetSubscriptionWithContext(ctx context.Context, getSubscriptionOptions *GetSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubscriptionOptions, "getSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubscriptionOptions, "getSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *getSubscriptionOptions.InstanceID,
		"id":          *getSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "GetSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteSubscription : Delete a Subscription
// Delete a Subscription.
func (eventNotifications *EventNotificationsV1) DeleteSubscription(deleteSubscriptionOptions *DeleteSubscriptionOptions) (response *core.DetailedResponse, err error) {
	return eventNotifications.DeleteSubscriptionWithContext(context.Background(), deleteSubscriptionOptions)
}

// DeleteSubscriptionWithContext is an alternate form of the DeleteSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) DeleteSubscriptionWithContext(ctx context.Context, deleteSubscriptionOptions *DeleteSubscriptionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSubscriptionOptions, "deleteSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSubscriptionOptions, "deleteSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *deleteSubscriptionOptions.InstanceID,
		"id":          *deleteSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "DeleteSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = eventNotifications.Service.Request(request, nil)

	return
}

// UpdateSubscription : Update details of a Subscription
// Update details of a Subscription.
func (eventNotifications *EventNotificationsV1) UpdateSubscription(updateSubscriptionOptions *UpdateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return eventNotifications.UpdateSubscriptionWithContext(context.Background(), updateSubscriptionOptions)
}

// UpdateSubscriptionWithContext is an alternate form of the UpdateSubscription method which supports a Context parameter
func (eventNotifications *EventNotificationsV1) UpdateSubscriptionWithContext(ctx context.Context, updateSubscriptionOptions *UpdateSubscriptionOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSubscriptionOptions, "updateSubscriptionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSubscriptionOptions, "updateSubscriptionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *updateSubscriptionOptions.InstanceID,
		"id":          *updateSubscriptionOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = eventNotifications.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(eventNotifications.Service.Options.URL, `/v1/instances/{instance_id}/subscriptions/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSubscriptionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("event_notifications", "V1", "UpdateSubscription")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSubscriptionOptions.Name != nil {
		body["name"] = updateSubscriptionOptions.Name
	}
	if updateSubscriptionOptions.Description != nil {
		body["description"] = updateSubscriptionOptions.Description
	}
	if updateSubscriptionOptions.Attributes != nil {
		body["attributes"] = updateSubscriptionOptions.Attributes
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = eventNotifications.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateDestinationOptions : The CreateDestination options.
type CreateDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The Destintion name.
	Name *string `json:"name" validate:"required"`

	// The type of Destination Webhook.
	Type *string `json:"type" validate:"required"`

	// The Destination description.
	Description *string `json:"description,omitempty"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the CreateDestinationOptions.Type property.
// The type of Destination Webhook.
const (
	CreateDestinationOptionsTypePushAndroidConst = "push_android"
	CreateDestinationOptionsTypeWebhookConst     = "webhook"
)

// NewCreateDestinationOptions : Instantiate CreateDestinationOptions
func (*EventNotificationsV1) NewCreateDestinationOptions(instanceID string, name string, typeVar string) *CreateDestinationOptions {
	return &CreateDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		Name:       core.StringPtr(name),
		Type:       core.StringPtr(typeVar),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateDestinationOptions) SetInstanceID(instanceID string) *CreateDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateDestinationOptions) SetName(name string) *CreateDestinationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetType : Allow user to set Type
func (_options *CreateDestinationOptions) SetType(typeVar string) *CreateDestinationOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateDestinationOptions) SetDescription(description string) *CreateDestinationOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetConfig : Allow user to set Config
func (_options *CreateDestinationOptions) SetConfig(config *DestinationConfig) *CreateDestinationOptions {
	_options.Config = config
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateDestinationOptions) SetHeaders(param map[string]string) *CreateDestinationOptions {
	options.Headers = param
	return options
}

// CreateSubscriptionOptions : The CreateSubscription options.
type CreateSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Subscription name.
	Name *string `json:"name" validate:"required"`

	// Destination ID.
	DestinationID *string `json:"destination_id" validate:"required"`

	// Topic ID.
	TopicID *string `json:"topic_id" validate:"required"`

	// Subscription description.
	Description *string `json:"description,omitempty"`

	Attributes SubscriptionCreateAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSubscriptionOptions : Instantiate CreateSubscriptionOptions
func (*EventNotificationsV1) NewCreateSubscriptionOptions(instanceID string, name string, destinationID string, topicID string) *CreateSubscriptionOptions {
	return &CreateSubscriptionOptions{
		InstanceID:    core.StringPtr(instanceID),
		Name:          core.StringPtr(name),
		DestinationID: core.StringPtr(destinationID),
		TopicID:       core.StringPtr(topicID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateSubscriptionOptions) SetInstanceID(instanceID string) *CreateSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateSubscriptionOptions) SetName(name string) *CreateSubscriptionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDestinationID : Allow user to set DestinationID
func (_options *CreateSubscriptionOptions) SetDestinationID(destinationID string) *CreateSubscriptionOptions {
	_options.DestinationID = core.StringPtr(destinationID)
	return _options
}

// SetTopicID : Allow user to set TopicID
func (_options *CreateSubscriptionOptions) SetTopicID(topicID string) *CreateSubscriptionOptions {
	_options.TopicID = core.StringPtr(topicID)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateSubscriptionOptions) SetDescription(description string) *CreateSubscriptionOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetAttributes : Allow user to set Attributes
func (_options *CreateSubscriptionOptions) SetAttributes(attributes SubscriptionCreateAttributesIntf) *CreateSubscriptionOptions {
	_options.Attributes = attributes
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSubscriptionOptions) SetHeaders(param map[string]string) *CreateSubscriptionOptions {
	options.Headers = param
	return options
}

// CreateTagsSubscriptionOptions : The CreateTagsSubscription options.
type CreateTagsSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Unique identifier of the device.
	DeviceID *string `json:"device_id" validate:"required"`

	// The name of the tag its subscribed.
	TagName *string `json:"tag_name" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTagsSubscriptionOptions : Instantiate CreateTagsSubscriptionOptions
func (*EventNotificationsV1) NewCreateTagsSubscriptionOptions(instanceID string, id string, deviceID string, tagName string) *CreateTagsSubscriptionOptions {
	return &CreateTagsSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		DeviceID:   core.StringPtr(deviceID),
		TagName:    core.StringPtr(tagName),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateTagsSubscriptionOptions) SetInstanceID(instanceID string) *CreateTagsSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *CreateTagsSubscriptionOptions) SetID(id string) *CreateTagsSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *CreateTagsSubscriptionOptions) SetDeviceID(deviceID string) *CreateTagsSubscriptionOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *CreateTagsSubscriptionOptions) SetTagName(tagName string) *CreateTagsSubscriptionOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTagsSubscriptionOptions) SetHeaders(param map[string]string) *CreateTagsSubscriptionOptions {
	options.Headers = param
	return options
}

// CreateTopicOptions : The CreateTopic options.
type CreateTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description,omitempty"`

	// List of sources.
	Sources []TopicUpdateSourcesItem `json:"sources,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTopicOptions : Instantiate CreateTopicOptions
func (*EventNotificationsV1) NewCreateTopicOptions(instanceID string, name string) *CreateTopicOptions {
	return &CreateTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		Name:       core.StringPtr(name),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *CreateTopicOptions) SetInstanceID(instanceID string) *CreateTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *CreateTopicOptions) SetName(name string) *CreateTopicOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *CreateTopicOptions) SetDescription(description string) *CreateTopicOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetSources : Allow user to set Sources
func (_options *CreateTopicOptions) SetSources(sources []TopicUpdateSourcesItem) *CreateTopicOptions {
	_options.Sources = sources
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTopicOptions) SetHeaders(param map[string]string) *CreateTopicOptions {
	options.Headers = param
	return options
}

// DeleteDestinationOptions : The DeleteDestination options.
type DeleteDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteDestinationOptions : Instantiate DeleteDestinationOptions
func (*EventNotificationsV1) NewDeleteDestinationOptions(instanceID string, id string) *DeleteDestinationOptions {
	return &DeleteDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteDestinationOptions) SetInstanceID(instanceID string) *DeleteDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteDestinationOptions) SetID(id string) *DeleteDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteDestinationOptions) SetHeaders(param map[string]string) *DeleteDestinationOptions {
	options.Headers = param
	return options
}

// DeleteSubscriptionOptions : The DeleteSubscription options.
type DeleteSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSubscriptionOptions : Instantiate DeleteSubscriptionOptions
func (*EventNotificationsV1) NewDeleteSubscriptionOptions(instanceID string, id string) *DeleteSubscriptionOptions {
	return &DeleteSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteSubscriptionOptions) SetInstanceID(instanceID string) *DeleteSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteSubscriptionOptions) SetID(id string) *DeleteSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSubscriptionOptions) SetHeaders(param map[string]string) *DeleteSubscriptionOptions {
	options.Headers = param
	return options
}

// DeleteTagsSubscriptionOptions : The DeleteTagsSubscription options.
type DeleteTagsSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// DeviceID of the destination tagsubscription.
	DeviceID *string `json:"device_id,omitempty"`

	// TagName of the subscription.
	TagName *string `json:"tag_name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTagsSubscriptionOptions : Instantiate DeleteTagsSubscriptionOptions
func (*EventNotificationsV1) NewDeleteTagsSubscriptionOptions(instanceID string, id string) *DeleteTagsSubscriptionOptions {
	return &DeleteTagsSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteTagsSubscriptionOptions) SetInstanceID(instanceID string) *DeleteTagsSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTagsSubscriptionOptions) SetID(id string) *DeleteTagsSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *DeleteTagsSubscriptionOptions) SetDeviceID(deviceID string) *DeleteTagsSubscriptionOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *DeleteTagsSubscriptionOptions) SetTagName(tagName string) *DeleteTagsSubscriptionOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTagsSubscriptionOptions) SetHeaders(param map[string]string) *DeleteTagsSubscriptionOptions {
	options.Headers = param
	return options
}

// DeleteTopicOptions : The DeleteTopic options.
type DeleteTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteTopicOptions : Instantiate DeleteTopicOptions
func (*EventNotificationsV1) NewDeleteTopicOptions(instanceID string, id string) *DeleteTopicOptions {
	return &DeleteTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *DeleteTopicOptions) SetInstanceID(instanceID string) *DeleteTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *DeleteTopicOptions) SetID(id string) *DeleteTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteTopicOptions) SetHeaders(param map[string]string) *DeleteTopicOptions {
	options.Headers = param
	return options
}

// Destination : Payload describing a destination get request.
type Destination struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type Email/SMS/Webhook/FCM.
	Type *string `json:"type" validate:"required"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Last updated time.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// List of subscriptions.
	SubscriptionNames []string `json:"subscription_names" validate:"required"`
}

// Constants associated with the Destination.Type property.
// Destination type Email/SMS/Webhook/FCM.
const (
	DestinationTypePushAndroidConst = "push_android"
	DestinationTypeSMTPIBMConst     = "smtp_ibm"
	DestinationTypeSmsIBMConst      = "sms_ibm"
	DestinationTypeWebhookConst     = "webhook"
)

// UnmarshalDestination unmarshals an instance of Destination from the specified map of raw messages.
func UnmarshalDestination(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Destination)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "config", &obj.Config, UnmarshalDestinationConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_names", &obj.SubscriptionNames)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfig : Payload describing a destination configuration.
type DestinationConfig struct {
	Params DestinationConfigParamsIntf `json:"params" validate:"required"`
}

// NewDestinationConfig : Instantiate DestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfig(params DestinationConfigParamsIntf) (_model *DestinationConfig, err error) {
	_model = &DestinationConfig{
		Params: params,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalDestinationConfig unmarshals an instance of DestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfig)
	err = core.UnmarshalModel(m, "params", &obj.Params, UnmarshalDestinationConfigParams)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigParams : DestinationConfigParams struct
// Models which "extend" this model:
// - DestinationConfigParamsWebhookDestinationConfig
// - DestinationConfigParamsFcmDestinationConfig
type DestinationConfigParams struct {
	// URL of webhook.
	URL *string `json:"url,omitempty"`

	// HTTP method of webhook.
	Verb *string `json:"verb,omitempty"`

	// Custom headers (Key-Value pair) for webhook call.
	CustomHeaders map[string]string `json:"custom_headers,omitempty"`

	// List of sensitive headers from custom headers.
	SensitiveHeaders []string `json:"sensitive_headers,omitempty"`

	// FCM server_key.
	ServerKey *string `json:"server_key,omitempty"`

	// FCM sender_id.
	SenderID *string `json:"sender_id,omitempty"`
}

// Constants associated with the DestinationConfigParams.Verb property.
// HTTP method of webhook.
const (
	DestinationConfigParamsVerbGetConst  = "get"
	DestinationConfigParamsVerbPostConst = "post"
)

func (*DestinationConfigParams) isaDestinationConfigParams() bool {
	return true
}

type DestinationConfigParamsIntf interface {
	isaDestinationConfigParams() bool
}

// UnmarshalDestinationConfigParams unmarshals an instance of DestinationConfigParams from the specified map of raw messages.
func UnmarshalDestinationConfigParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParams)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verb", &obj.Verb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "custom_headers", &obj.CustomHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sensitive_headers", &obj.SensitiveHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "server_key", &obj.ServerKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sender_id", &obj.SenderID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationDevicesList : Payload describing a destination devices list request.
type DestinationDevicesList struct {
	// Total number of destination devices.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show destination devices.
	Limit *int64 `json:"limit" validate:"required"`

	// List of devices.
	Devices []DestinationDevicesListItem `json:"devices" validate:"required"`
}

// UnmarshalDestinationDevicesList unmarshals an instance of DestinationDevicesList from the specified map of raw messages.
func UnmarshalDestinationDevicesList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationDevicesList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "devices", &obj.Devices, UnmarshalDestinationDevicesListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationDevicesListItem : device object.
type DestinationDevicesListItem struct {
	// device ID.
	ID *string `json:"id" validate:"required"`

	// user ID.
	UserID *string `json:"user_id,omitempty"`

	// Destination platform.
	Platform *string `json:"platform" validate:"required"`

	// Destination device token.
	Token *string `json:"token" validate:"required"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalDestinationDevicesListItem unmarshals an instance of DestinationDevicesListItem from the specified map of raw messages.
func UnmarshalDestinationDevicesListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationDevicesListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_id", &obj.UserID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "platform", &obj.Platform)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "token", &obj.Token)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationDevicesReport : Payload describing a destination devices report.
type DestinationDevicesReport struct {
	// Android Devices Registered.
	Android *int64 `json:"android" validate:"required"`

	// ios Devices Registered.
	Ios *int64 `json:"ios" validate:"required"`

	// chrome web Devices Registered.
	Chrome *int64 `json:"chrome" validate:"required"`

	// firefox web Devices Registered.
	Firefox *int64 `json:"firefox" validate:"required"`

	// safari web Devices Registered.
	Safari *int64 `json:"safari" validate:"required"`

	// chromeAppExt Devices Registered.
	ChromeAppExt *int64 `json:"chromeAppExt" validate:"required"`

	// Total Devices Registered.
	All *int64 `json:"all" validate:"required"`
}

// UnmarshalDestinationDevicesReport unmarshals an instance of DestinationDevicesReport from the specified map of raw messages.
func UnmarshalDestinationDevicesReport(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationDevicesReport)
	err = core.UnmarshalPrimitive(m, "android", &obj.Android)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ios", &obj.Ios)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "chrome", &obj.Chrome)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "firefox", &obj.Firefox)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "safari", &obj.Safari)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "chromeAppExt", &obj.ChromeAppExt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "all", &obj.All)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationList : Payload describing a destination list request.
type DestinationList struct {
	// Total number of destinations.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show destinations.
	Limit *int64 `json:"limit" validate:"required"`

	// List of destinations.
	Destinations []DestinationListItem `json:"destinations" validate:"required"`
}

// UnmarshalDestinationList unmarshals an instance of DestinationList from the specified map of raw messages.
func UnmarshalDestinationList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "destinations", &obj.Destinations, UnmarshalDestinationListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationListItem : Destination object.
type DestinationListItem struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type Email/SMS/Webhook.
	Type *string `json:"type" validate:"required"`

	// Subscription count.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// Names of subscriptions.
	SubscriptionNames []string `json:"subscription_names" validate:"required"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the DestinationListItem.Type property.
// Destination type Email/SMS/Webhook.
const (
	DestinationListItemTypePushAndroidConst = "push_android"
	DestinationListItemTypeSMTPIBMConst     = "smtp_ibm"
	DestinationListItemTypeSmsIBMConst      = "sms_ibm"
	DestinationListItemTypeWebhookConst     = "webhook"
)

// UnmarshalDestinationListItem unmarshals an instance of DestinationListItem from the specified map of raw messages.
func UnmarshalDestinationListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_names", &obj.SubscriptionNames)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationResponse : Payload describing a destination get request.
type DestinationResponse struct {
	// Destination ID.
	ID *string `json:"id" validate:"required"`

	// Destination name.
	Name *string `json:"name" validate:"required"`

	// Destination description.
	Description *string `json:"description" validate:"required"`

	// Destination type Email/SMS/Webhook.
	Type *string `json:"type" validate:"required"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config" validate:"required"`

	// Last updated time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// Constants associated with the DestinationResponse.Type property.
// Destination type Email/SMS/Webhook.
const (
	DestinationResponseTypeWebhookConst = "webhook"
)

// UnmarshalDestinationResponse unmarshals an instance of DestinationResponse from the specified map of raw messages.
func UnmarshalDestinationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "config", &obj.Config, UnmarshalDestinationConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationTagsSubscriptionResponse : Payload describing a destination get request.
type DestinationTagsSubscriptionResponse struct {
	// Subscription Tag ID.
	ID *string `json:"id" validate:"required"`

	// Unique identifier of the device.
	DeviceID *string `json:"device_id" validate:"required"`

	// The name of the tag its subscribed.
	TagName *string `json:"tag_name" validate:"required"`

	// The user identifier for the the device registration.
	UserID *string `json:"user_id,omitempty"`

	// Last updated time.
	CreatedAt *strfmt.DateTime `json:"created_at" validate:"required"`
}

// UnmarshalDestinationTagsSubscriptionResponse unmarshals an instance of DestinationTagsSubscriptionResponse from the specified map of raw messages.
func UnmarshalDestinationTagsSubscriptionResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationTagsSubscriptionResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tag_name", &obj.TagName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_id", &obj.UserID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EmailUpdateAttributesTo : The email ids.
type EmailUpdateAttributesTo struct {
	// The email ids.
	Add []string `json:"add,omitempty"`

	// The email ids for removal.
	Remove []string `json:"remove,omitempty"`
}

// UnmarshalEmailUpdateAttributesTo unmarshals an instance of EmailUpdateAttributesTo from the specified map of raw messages.
func UnmarshalEmailUpdateAttributesTo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EmailUpdateAttributesTo)
	err = core.UnmarshalPrimitive(m, "add", &obj.Add)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remove", &obj.Remove)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EmailUpdateAttributesUnsubscribed : The email ids.
type EmailUpdateAttributesUnsubscribed struct {
	// The email ids unsubscribed.
	Remove []string `json:"remove,omitempty"`
}

// UnmarshalEmailUpdateAttributesUnsubscribed unmarshals an instance of EmailUpdateAttributesUnsubscribed from the specified map of raw messages.
func UnmarshalEmailUpdateAttributesUnsubscribed(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EmailUpdateAttributesUnsubscribed)
	err = core.UnmarshalPrimitive(m, "remove", &obj.Remove)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetDestinationDevicesReportOptions : The GetDestinationDevicesReport options.
type GetDestinationDevicesReportOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Number of days report has to be generated from
	// * `Note :` Max value is 90
	// * Min or default value is 1.
	Days *int64 `json:"days,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDestinationDevicesReportOptions : Instantiate GetDestinationDevicesReportOptions
func (*EventNotificationsV1) NewGetDestinationDevicesReportOptions(instanceID string, id string) *GetDestinationDevicesReportOptions {
	return &GetDestinationDevicesReportOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetDestinationDevicesReportOptions) SetInstanceID(instanceID string) *GetDestinationDevicesReportOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetDestinationDevicesReportOptions) SetID(id string) *GetDestinationDevicesReportOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDays : Allow user to set Days
func (_options *GetDestinationDevicesReportOptions) SetDays(days int64) *GetDestinationDevicesReportOptions {
	_options.Days = core.Int64Ptr(days)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDestinationDevicesReportOptions) SetHeaders(param map[string]string) *GetDestinationDevicesReportOptions {
	options.Headers = param
	return options
}

// GetDestinationOptions : The GetDestination options.
type GetDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDestinationOptions : Instantiate GetDestinationOptions
func (*EventNotificationsV1) NewGetDestinationOptions(instanceID string, id string) *GetDestinationOptions {
	return &GetDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetDestinationOptions) SetInstanceID(instanceID string) *GetDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetDestinationOptions) SetID(id string) *GetDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetDestinationOptions) SetHeaders(param map[string]string) *GetDestinationOptions {
	options.Headers = param
	return options
}

// GetSourceOptions : The GetSource options.
type GetSourceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Source.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSourceOptions : Instantiate GetSourceOptions
func (*EventNotificationsV1) NewGetSourceOptions(instanceID string, id string) *GetSourceOptions {
	return &GetSourceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSourceOptions) SetInstanceID(instanceID string) *GetSourceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSourceOptions) SetID(id string) *GetSourceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSourceOptions) SetHeaders(param map[string]string) *GetSourceOptions {
	options.Headers = param
	return options
}

// GetSubscriptionOptions : The GetSubscription options.
type GetSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubscriptionOptions : Instantiate GetSubscriptionOptions
func (*EventNotificationsV1) NewGetSubscriptionOptions(instanceID string, id string) *GetSubscriptionOptions {
	return &GetSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetSubscriptionOptions) SetInstanceID(instanceID string) *GetSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetSubscriptionOptions) SetID(id string) *GetSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubscriptionOptions) SetHeaders(param map[string]string) *GetSubscriptionOptions {
	options.Headers = param
	return options
}

// GetTopicOptions : The GetTopic options.
type GetTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Include sub topics.
	Include *string `json:"include,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTopicOptions : Instantiate GetTopicOptions
func (*EventNotificationsV1) NewGetTopicOptions(instanceID string, id string) *GetTopicOptions {
	return &GetTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *GetTopicOptions) SetInstanceID(instanceID string) *GetTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *GetTopicOptions) SetID(id string) *GetTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetInclude : Allow user to set Include
func (_options *GetTopicOptions) SetInclude(include string) *GetTopicOptions {
	_options.Include = core.StringPtr(include)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetTopicOptions) SetHeaders(param map[string]string) *GetTopicOptions {
	options.Headers = param
	return options
}

// Lights : Allows setting the notification LED color on receiving push notification .
type Lights struct {
	// The color of the led. The hardware will do its best approximation.
	LedArgb *string `json:"led_argb,omitempty"`

	// The number of milliseconds for the LED to be on while it's flashing. The hardware will do its best approximation.
	LedOnMs *int64 `json:"led_on_ms,omitempty"`

	// The number of milliseconds for the LED to be off while it's flashing. The hardware will do its best approximation.
	LedOffMs *string `json:"led_off_ms,omitempty"`
}

// UnmarshalLights unmarshals an instance of Lights from the specified map of raw messages.
func UnmarshalLights(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Lights)
	err = core.UnmarshalPrimitive(m, "led_argb", &obj.LedArgb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "led_on_ms", &obj.LedOnMs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "led_off_ms", &obj.LedOffMs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ListDestinationDevicesOptions : The ListDestinationDevices options.
type ListDestinationDevicesOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDestinationDevicesOptions : Instantiate ListDestinationDevicesOptions
func (*EventNotificationsV1) NewListDestinationDevicesOptions(instanceID string, id string) *ListDestinationDevicesOptions {
	return &ListDestinationDevicesOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListDestinationDevicesOptions) SetInstanceID(instanceID string) *ListDestinationDevicesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListDestinationDevicesOptions) SetID(id string) *ListDestinationDevicesOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListDestinationDevicesOptions) SetLimit(limit int64) *ListDestinationDevicesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListDestinationDevicesOptions) SetOffset(offset int64) *ListDestinationDevicesOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListDestinationDevicesOptions) SetSearch(search string) *ListDestinationDevicesOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListDestinationDevicesOptions) SetHeaders(param map[string]string) *ListDestinationDevicesOptions {
	options.Headers = param
	return options
}

// ListDestinationsOptions : The ListDestinations options.
type ListDestinationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListDestinationsOptions : Instantiate ListDestinationsOptions
func (*EventNotificationsV1) NewListDestinationsOptions(instanceID string) *ListDestinationsOptions {
	return &ListDestinationsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListDestinationsOptions) SetInstanceID(instanceID string) *ListDestinationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListDestinationsOptions) SetLimit(limit int64) *ListDestinationsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListDestinationsOptions) SetOffset(offset int64) *ListDestinationsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListDestinationsOptions) SetSearch(search string) *ListDestinationsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListDestinationsOptions) SetHeaders(param map[string]string) *ListDestinationsOptions {
	options.Headers = param
	return options
}

// ListSourcesOptions : The ListSources options.
type ListSourcesOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSourcesOptions : Instantiate ListSourcesOptions
func (*EventNotificationsV1) NewListSourcesOptions(instanceID string) *ListSourcesOptions {
	return &ListSourcesOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListSourcesOptions) SetInstanceID(instanceID string) *ListSourcesOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSourcesOptions) SetLimit(limit int64) *ListSourcesOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListSourcesOptions) SetOffset(offset int64) *ListSourcesOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListSourcesOptions) SetSearch(search string) *ListSourcesOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSourcesOptions) SetHeaders(param map[string]string) *ListSourcesOptions {
	options.Headers = param
	return options
}

// ListSubscriptionsOptions : The ListSubscriptions options.
type ListSubscriptionsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSubscriptionsOptions : Instantiate ListSubscriptionsOptions
func (*EventNotificationsV1) NewListSubscriptionsOptions(instanceID string) *ListSubscriptionsOptions {
	return &ListSubscriptionsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListSubscriptionsOptions) SetInstanceID(instanceID string) *ListSubscriptionsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListSubscriptionsOptions) SetOffset(offset int64) *ListSubscriptionsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListSubscriptionsOptions) SetLimit(limit int64) *ListSubscriptionsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListSubscriptionsOptions) SetSearch(search string) *ListSubscriptionsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListSubscriptionsOptions) SetHeaders(param map[string]string) *ListSubscriptionsOptions {
	options.Headers = param
	return options
}

// ListTagsSubscriptionOptions : The ListTagsSubscription options.
type ListTagsSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// DeviceID of the destination tagsubscription.
	DeviceID *string `json:"device_id,omitempty"`

	// UserID of the destination.
	UserID *string `json:"user_id,omitempty"`

	// TagName of the subscription.
	TagName *string `json:"tag_name,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTagsSubscriptionOptions : Instantiate ListTagsSubscriptionOptions
func (*EventNotificationsV1) NewListTagsSubscriptionOptions(instanceID string, id string) *ListTagsSubscriptionOptions {
	return &ListTagsSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListTagsSubscriptionOptions) SetInstanceID(instanceID string) *ListTagsSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTagsSubscriptionOptions) SetID(id string) *ListTagsSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *ListTagsSubscriptionOptions) SetDeviceID(deviceID string) *ListTagsSubscriptionOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetUserID : Allow user to set UserID
func (_options *ListTagsSubscriptionOptions) SetUserID(userID string) *ListTagsSubscriptionOptions {
	_options.UserID = core.StringPtr(userID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *ListTagsSubscriptionOptions) SetTagName(tagName string) *ListTagsSubscriptionOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTagsSubscriptionOptions) SetLimit(limit int64) *ListTagsSubscriptionOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListTagsSubscriptionOptions) SetOffset(offset int64) *ListTagsSubscriptionOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListTagsSubscriptionOptions) SetSearch(search string) *ListTagsSubscriptionOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTagsSubscriptionOptions) SetHeaders(param map[string]string) *ListTagsSubscriptionOptions {
	options.Headers = param
	return options
}

// ListTagsSubscriptionsDeviceOptions : The ListTagsSubscriptionsDevice options.
type ListTagsSubscriptionsDeviceOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// DeviceID of the destination.
	DeviceID *string `json:"device_id" validate:"required,ne="`

	// TagName of the subscription.
	TagName *string `json:"tag_name,omitempty"`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTagsSubscriptionsDeviceOptions : Instantiate ListTagsSubscriptionsDeviceOptions
func (*EventNotificationsV1) NewListTagsSubscriptionsDeviceOptions(instanceID string, id string, deviceID string) *ListTagsSubscriptionsDeviceOptions {
	return &ListTagsSubscriptionsDeviceOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
		DeviceID:   core.StringPtr(deviceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListTagsSubscriptionsDeviceOptions) SetInstanceID(instanceID string) *ListTagsSubscriptionsDeviceOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ListTagsSubscriptionsDeviceOptions) SetID(id string) *ListTagsSubscriptionsDeviceOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetDeviceID : Allow user to set DeviceID
func (_options *ListTagsSubscriptionsDeviceOptions) SetDeviceID(deviceID string) *ListTagsSubscriptionsDeviceOptions {
	_options.DeviceID = core.StringPtr(deviceID)
	return _options
}

// SetTagName : Allow user to set TagName
func (_options *ListTagsSubscriptionsDeviceOptions) SetTagName(tagName string) *ListTagsSubscriptionsDeviceOptions {
	_options.TagName = core.StringPtr(tagName)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTagsSubscriptionsDeviceOptions) SetLimit(limit int64) *ListTagsSubscriptionsDeviceOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListTagsSubscriptionsDeviceOptions) SetOffset(offset int64) *ListTagsSubscriptionsDeviceOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTagsSubscriptionsDeviceOptions) SetHeaders(param map[string]string) *ListTagsSubscriptionsDeviceOptions {
	options.Headers = param
	return options
}

// ListTopicsOptions : The ListTopics options.
type ListTopicsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Page limit for paginated results.
	Limit *int64 `json:"limit,omitempty"`

	// offset for paginated results.
	Offset *int64 `json:"offset,omitempty"`

	// Search string for filtering results.
	Search *string `json:"search,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListTopicsOptions : Instantiate ListTopicsOptions
func (*EventNotificationsV1) NewListTopicsOptions(instanceID string) *ListTopicsOptions {
	return &ListTopicsOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ListTopicsOptions) SetInstanceID(instanceID string) *ListTopicsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetLimit : Allow user to set Limit
func (_options *ListTopicsOptions) SetLimit(limit int64) *ListTopicsOptions {
	_options.Limit = core.Int64Ptr(limit)
	return _options
}

// SetOffset : Allow user to set Offset
func (_options *ListTopicsOptions) SetOffset(offset int64) *ListTopicsOptions {
	_options.Offset = core.Int64Ptr(offset)
	return _options
}

// SetSearch : Allow user to set Search
func (_options *ListTopicsOptions) SetSearch(search string) *ListTopicsOptions {
	_options.Search = core.StringPtr(search)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListTopicsOptions) SetHeaders(param map[string]string) *ListTopicsOptions {
	options.Headers = param
	return options
}

// NotificationFcmBody : Payload describing a FCM Notifications body.
type NotificationFcmBody struct {
	// Payload describing a fcm notifications body message.
	Message *NotificationFcmBodyMessage `json:"message" validate:"required"`
}

// NewNotificationFcmBody : Instantiate NotificationFcmBody (Generic Model Constructor)
func (*EventNotificationsV1) NewNotificationFcmBody(message *NotificationFcmBodyMessage) (_model *NotificationFcmBody, err error) {
	_model = &NotificationFcmBody{
		Message: message,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalNotificationFcmBody unmarshals an instance of NotificationFcmBody from the specified map of raw messages.
func UnmarshalNotificationFcmBody(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NotificationFcmBody)
	err = core.UnmarshalModel(m, "message", &obj.Message, UnmarshalNotificationFcmBodyMessage)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NotificationFcmBodyMessage : Payload describing a fcm notifications body message.
type NotificationFcmBodyMessage struct {
	// Payload describing a fcm notifications body message Data.
	Data *NotificationFcmBodyMessageData `json:"data" validate:"required"`
}

// NewNotificationFcmBodyMessage : Instantiate NotificationFcmBodyMessage (Generic Model Constructor)
func (*EventNotificationsV1) NewNotificationFcmBodyMessage(data *NotificationFcmBodyMessageData) (_model *NotificationFcmBodyMessage, err error) {
	_model = &NotificationFcmBodyMessage{
		Data: data,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalNotificationFcmBodyMessage unmarshals an instance of NotificationFcmBodyMessage from the specified map of raw messages.
func UnmarshalNotificationFcmBodyMessage(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NotificationFcmBodyMessage)
	err = core.UnmarshalModel(m, "data", &obj.Data, UnmarshalNotificationFcmBodyMessageData)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NotificationFcmBodyMessageData : Payload describing a fcm notifications body message Data.
type NotificationFcmBodyMessageData struct {
	// The notification message to be shown to the user.
	Alert *string `json:"alert" validate:"required"`

	// Dozed devices to display only the latest notification and discard old low priority notifications.
	CollapseKey *string `json:"collapse_key,omitempty"`

	// The category identifier to be used for the interactive push notifications.
	InteractiveCategory *string `json:"interactive_category,omitempty"`

	// Specify the name of the icon to be displayed for the notification. Make sure the icon is already packaged with the
	// client application.
	Icon *string `json:"icon,omitempty"`

	// When this parameter is set to true, it indicates that the
	//   message should not be sent until the device becomes active.
	DelayWhileIdle *bool `json:"delay_while_idle,omitempty"`

	// Device group messaging makes it possible for every app instance in a group to reflect the latest messaging state.
	Sync *bool `json:"sync,omitempty"`

	// private/public - Visibility of this notification, which affects how and when the notifications are revealed on a
	// secure locked screen.
	Visibility *string `json:"visibility,omitempty"`

	// Content specified will show up on a secure locked screen on the device when visibility is set to Private.
	Redact *string `json:"redact,omitempty"`

	// Custom JSON payload that will be sent as part of the notification message.
	Payload map[string]interface{} `json:"payload,omitempty"`

	// A string value that indicates the priority of this notification. Allowed values are 'max', 'high', 'default', 'low'
	// and 'min'. High/Max priority notifications along with 'sound' field may be used for Heads up notification in Android
	// 5.0 or higher.sampleval='low'.
	Priority *string `json:"priority,omitempty"`

	// The sound file (on device) that will be attempted to play when the notification arrives on the device.
	Sound *string `json:"sound,omitempty"`

	// This parameter specifies how long (in seconds) the message
	//   should be kept in GCM storage if the device is offline.
	TimeToLive *int64 `json:"time_to_live,omitempty"`

	// Allows setting the notification LED color on receiving push notification .
	Lights *Lights `json:"lights,omitempty"`

	// The title of Rich Push notifications.
	AndroidTitle *string `json:"android_title,omitempty"`

	// Set this notification to be part of a group of notifications sharing the same key. Grouped notifications may display
	// in a cluster or stack on devices which support such rendering.
	GroupID *string `json:"group_id,omitempty"`

	// Options to specify for Android expandable notifications. The types of expandable notifications are
	// picture_notification, bigtext_notification, inbox_notification.
	Style *Style `json:"style,omitempty"`

	// Notification type.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the NotificationFcmBodyMessageData.Type property.
// Notification type.
const (
	NotificationFcmBodyMessageDataTypeDefaultConst = "DEFAULT"
	NotificationFcmBodyMessageDataTypeSilentConst  = "SILENT"
)

// NewNotificationFcmBodyMessageData : Instantiate NotificationFcmBodyMessageData (Generic Model Constructor)
func (*EventNotificationsV1) NewNotificationFcmBodyMessageData(alert string) (_model *NotificationFcmBodyMessageData, err error) {
	_model = &NotificationFcmBodyMessageData{
		Alert: core.StringPtr(alert),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalNotificationFcmBodyMessageData unmarshals an instance of NotificationFcmBodyMessageData from the specified map of raw messages.
func UnmarshalNotificationFcmBodyMessageData(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NotificationFcmBodyMessageData)
	err = core.UnmarshalPrimitive(m, "alert", &obj.Alert)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "collapse_key", &obj.CollapseKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interactive_category", &obj.InteractiveCategory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "icon", &obj.Icon)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "delay_while_idle", &obj.DelayWhileIdle)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sync", &obj.Sync)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "visibility", &obj.Visibility)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "redact", &obj.Redact)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "payload", &obj.Payload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "priority", &obj.Priority)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sound", &obj.Sound)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "time_to_live", &obj.TimeToLive)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lights", &obj.Lights, UnmarshalLights)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "android_title", &obj.AndroidTitle)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "group_id", &obj.GroupID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "style", &obj.Style, UnmarshalStyle)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NotificationFcmDevices : Payload describing a FCM Notifications targets.
type NotificationFcmDevices struct {
	// List of deviceIds.
	FcmDevices []string `json:"fcm_devices,omitempty"`

	// List of userIds.
	UserIds []string `json:"user_ids,omitempty"`

	// List of tags.
	Tags []string `json:"tags,omitempty"`

	// List of platforms.
	Platforms []string `json:"platforms,omitempty"`
}

// UnmarshalNotificationFcmDevices unmarshals an instance of NotificationFcmDevices from the specified map of raw messages.
func UnmarshalNotificationFcmDevices(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NotificationFcmDevices)
	err = core.UnmarshalPrimitive(m, "fcm_devices", &obj.FcmDevices)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_ids", &obj.UserIds)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tags", &obj.Tags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "platforms", &obj.Platforms)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NotificationResponse : Payload describing a notifications response.
type NotificationResponse struct {
	// Notification ID.
	NotificationID *string `json:"notification_id" validate:"required"`
}

// UnmarshalNotificationResponse unmarshals an instance of NotificationResponse from the specified map of raw messages.
func UnmarshalNotificationResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NotificationResponse)
	err = core.UnmarshalPrimitive(m, "notification_id", &obj.NotificationID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ReplaceTopicOptions : The ReplaceTopic options.
type ReplaceTopicOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Topic.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the topic.
	Name *string `json:"name,omitempty"`

	// Description of the topic.
	Description *string `json:"description,omitempty"`

	// List of sources.
	Sources []TopicUpdateSourcesItem `json:"sources,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceTopicOptions : Instantiate ReplaceTopicOptions
func (*EventNotificationsV1) NewReplaceTopicOptions(instanceID string, id string) *ReplaceTopicOptions {
	return &ReplaceTopicOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ReplaceTopicOptions) SetInstanceID(instanceID string) *ReplaceTopicOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *ReplaceTopicOptions) SetID(id string) *ReplaceTopicOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *ReplaceTopicOptions) SetName(name string) *ReplaceTopicOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *ReplaceTopicOptions) SetDescription(description string) *ReplaceTopicOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetSources : Allow user to set Sources
func (_options *ReplaceTopicOptions) SetSources(sources []TopicUpdateSourcesItem) *ReplaceTopicOptions {
	_options.Sources = sources
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceTopicOptions) SetHeaders(param map[string]string) *ReplaceTopicOptions {
	options.Headers = param
	return options
}

// Rules : Rule object.
type Rules struct {
	// Whether the rule is enabled or not.
	Enabled *bool `json:"enabled,omitempty"`

	// Event type filter.
	EventTypeFilter *string `json:"event_type_filter" validate:"required"`

	// Notification filter.
	NotificationFilter *string `json:"notification_filter,omitempty"`
}

// NewRules : Instantiate Rules (Generic Model Constructor)
func (*EventNotificationsV1) NewRules(eventTypeFilter string) (_model *Rules, err error) {
	_model = &Rules{
		EventTypeFilter: core.StringPtr(eventTypeFilter),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalRules unmarshals an instance of Rules from the specified map of raw messages.
func UnmarshalRules(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Rules)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "event_type_filter", &obj.EventTypeFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "notification_filter", &obj.NotificationFilter)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RulesGet : Rule object.
type RulesGet struct {
	// Whether the rule is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Event type filter.
	EventTypeFilter *string `json:"event_type_filter" validate:"required"`

	// Notification filter.
	NotificationFilter *string `json:"notification_filter" validate:"required"`

	// Last time the topic was updated.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// Autogenerated rule ID.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalRulesGet unmarshals an instance of RulesGet from the specified map of raw messages.
func UnmarshalRulesGet(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RulesGet)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "event_type_filter", &obj.EventTypeFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "notification_filter", &obj.NotificationFilter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SendNotificationsOptions : The SendNotifications options.
type SendNotificationsOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// The Notifications subject.
	Subject *string `json:"subject" validate:"required"`

	// The Notifications severity.
	Severity *string `json:"severity" validate:"required"`

	// The Notifications id.
	ID *string `json:"id" validate:"required"`

	// The source of Notifications.
	Source *string `json:"source" validate:"required"`

	// The Event Notifications source id.
	EnSourceID *string `json:"en_source_id" validate:"required"`

	// The Notifications type.
	Type *string `json:"type" validate:"required"`

	// The Notifications time.
	Time *strfmt.DateTime `json:"time" validate:"required"`

	// The Notifications data for webhook.
	Data map[string]interface{} `json:"data,omitempty"`

	// Payload describing a FCM Notifications targets.
	PushTo *NotificationFcmDevices `json:"push_to,omitempty"`

	// Payload describing a FCM Notifications body.
	MessageFcmBody *NotificationFcmBody `json:"message_fcm_body,omitempty"`

	// The Notifications content type.
	Datacontenttype *string `json:"datacontenttype,omitempty"`

	// The Notifications specversion.
	Specversion *string `json:"specversion,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewSendNotificationsOptions : Instantiate SendNotificationsOptions
func (*EventNotificationsV1) NewSendNotificationsOptions(instanceID string, subject string, severity string, id string, source string, enSourceID string, typeVar string, time *strfmt.DateTime) *SendNotificationsOptions {
	return &SendNotificationsOptions{
		InstanceID: core.StringPtr(instanceID),
		Subject:    core.StringPtr(subject),
		Severity:   core.StringPtr(severity),
		ID:         core.StringPtr(id),
		Source:     core.StringPtr(source),
		EnSourceID: core.StringPtr(enSourceID),
		Type:       core.StringPtr(typeVar),
		Time:       time,
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *SendNotificationsOptions) SetInstanceID(instanceID string) *SendNotificationsOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetSubject : Allow user to set Subject
func (_options *SendNotificationsOptions) SetSubject(subject string) *SendNotificationsOptions {
	_options.Subject = core.StringPtr(subject)
	return _options
}

// SetSeverity : Allow user to set Severity
func (_options *SendNotificationsOptions) SetSeverity(severity string) *SendNotificationsOptions {
	_options.Severity = core.StringPtr(severity)
	return _options
}

// SetID : Allow user to set ID
func (_options *SendNotificationsOptions) SetID(id string) *SendNotificationsOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetSource : Allow user to set Source
func (_options *SendNotificationsOptions) SetSource(source string) *SendNotificationsOptions {
	_options.Source = core.StringPtr(source)
	return _options
}

// SetEnSourceID : Allow user to set EnSourceID
func (_options *SendNotificationsOptions) SetEnSourceID(enSourceID string) *SendNotificationsOptions {
	_options.EnSourceID = core.StringPtr(enSourceID)
	return _options
}

// SetType : Allow user to set Type
func (_options *SendNotificationsOptions) SetType(typeVar string) *SendNotificationsOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetTime : Allow user to set Time
func (_options *SendNotificationsOptions) SetTime(time *strfmt.DateTime) *SendNotificationsOptions {
	_options.Time = time
	return _options
}

// SetData : Allow user to set Data
func (_options *SendNotificationsOptions) SetData(data map[string]interface{}) *SendNotificationsOptions {
	_options.Data = data
	return _options
}

// SetPushTo : Allow user to set PushTo
func (_options *SendNotificationsOptions) SetPushTo(pushTo *NotificationFcmDevices) *SendNotificationsOptions {
	_options.PushTo = pushTo
	return _options
}

// SetMessageFcmBody : Allow user to set MessageFcmBody
func (_options *SendNotificationsOptions) SetMessageFcmBody(messageFcmBody *NotificationFcmBody) *SendNotificationsOptions {
	_options.MessageFcmBody = messageFcmBody
	return _options
}

// SetDatacontenttype : Allow user to set Datacontenttype
func (_options *SendNotificationsOptions) SetDatacontenttype(datacontenttype string) *SendNotificationsOptions {
	_options.Datacontenttype = core.StringPtr(datacontenttype)
	return _options
}

// SetSpecversion : Allow user to set Specversion
func (_options *SendNotificationsOptions) SetSpecversion(specversion string) *SendNotificationsOptions {
	_options.Specversion = core.StringPtr(specversion)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *SendNotificationsOptions) SetHeaders(param map[string]string) *SendNotificationsOptions {
	options.Headers = param
	return options
}

// Source : Payload describing a source generate request.
type Source struct {
	// The id of the source.
	ID *string `json:"id" validate:"required"`

	// The name of the source.
	Name *string `json:"name" validate:"required"`

	// The description of the source.
	Description *string `json:"description" validate:"required"`

	// The status of the source.
	Enabled *bool `json:"enabled" validate:"required"`

	// Type of the source.
	Type *string `json:"type" validate:"required"`

	// The last updated time of the source.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// The number of topics.
	TopicCount *int64 `json:"topic_count" validate:"required"`

	// The names of the topics.
	TopicNames []string `json:"topic_names" validate:"required"`
}

// UnmarshalSource unmarshals an instance of Source from the specified map of raw messages.
func UnmarshalSource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Source)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_count", &obj.TopicCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_names", &obj.TopicNames)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourceList : Payload describing a source list request.
type SourceList struct {
	// Number of sources.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show sources.
	Limit *int64 `json:"limit" validate:"required"`

	// List of sources.
	Sources []SourceListItem `json:"sources" validate:"required"`
}

// UnmarshalSourceList unmarshals an instance of SourceList from the specified map of raw messages.
func UnmarshalSourceList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sources", &obj.Sources, UnmarshalSourceListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourceListItem : Payload describing a source list item.
type SourceListItem struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// Description of the source.
	Description *string `json:"description" validate:"required"`

	// Type of the source.
	Type *string `json:"type" validate:"required"`

	// Whether the source is enabled or not.
	Enabled *bool `json:"enabled" validate:"required"`

	// Time of the last update.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`

	// Number of topics.
	TopicCount *int64 `json:"topic_count" validate:"required"`
}

// UnmarshalSourceListItem unmarshals an instance of SourceListItem from the specified map of raw messages.
func UnmarshalSourceListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourceListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_count", &obj.TopicCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SourcesListItem : SourcesListItem struct
type SourcesListItem struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// Name of the source.
	Name *string `json:"name" validate:"required"`

	// List of rules.
	Rules []RulesGet `json:"rules" validate:"required"`
}

// UnmarshalSourcesListItem unmarshals an instance of SourcesListItem from the specified map of raw messages.
func UnmarshalSourcesListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SourcesListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalRulesGet)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Style : Options to specify for Android expandable notifications. The types of expandable notifications are
// picture_notification, bigtext_notification, inbox_notification.
type Style struct {
	// Specifies the type of expandable notifications.  The possible values are bigtext_notification, picture_notification,
	// inbox_notification.
	Type *string `json:"type,omitempty"`

	// Specifies the title of the notification.  The title is displayed when the notification is expanded.  Title must be
	// specified for all three expandable notification.
	Title *string `json:"title,omitempty"`

	// An URL from which the picture has to be obtained for the notification.  Must be specified for picture_notification.
	URL *string `json:"url,omitempty"`

	// The big text that needs to be displayed on expanding a bigtext_notification.  Must be specified for
	// bigtext_notification.
	Text *string `json:"text,omitempty"`

	// An array of strings that is to be displayed in inbox style for inbox_notification.  Must be specified for
	// inbox_notification.
	Lines []string `json:"lines,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of Style
func (o *Style) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of Style
func (o *Style) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of Style
func (o *Style) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of Style
func (o *Style) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of Style
func (o *Style) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Type != nil {
		m["type"] = o.Type
	}
	if o.Title != nil {
		m["title"] = o.Title
	}
	if o.URL != nil {
		m["url"] = o.URL
	}
	if o.Text != nil {
		m["text"] = o.Text
	}
	if o.Lines != nil {
		m["lines"] = o.Lines
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalStyle unmarshals an instance of Style from the specified map of raw messages.
func UnmarshalStyle(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Style)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	delete(m, "type")
	err = core.UnmarshalPrimitive(m, "title", &obj.Title)
	if err != nil {
		return
	}
	delete(m, "title")
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	delete(m, "url")
	err = core.UnmarshalPrimitive(m, "text", &obj.Text)
	if err != nil {
		return
	}
	delete(m, "text")
	err = core.UnmarshalPrimitive(m, "lines", &obj.Lines)
	if err != nil {
		return
	}
	delete(m, "lines")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Subscription : Subscription object.
type Subscription struct {
	// Subscription ID.
	ID *string `json:"id" validate:"required"`

	// Subscription name.
	Name *string `json:"name" validate:"required"`

	// Subscription description.
	Description *string `json:"description" validate:"required"`

	// Last updated time.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// From Email ID (it will be displayed only in case of smtp_ibm destination type).
	From *string `json:"from,omitempty"`

	// The type of destination.
	DestinationType *string `json:"destination_type" validate:"required"`

	// The destination ID.
	DestinationID *string `json:"destination_id" validate:"required"`

	// The destination name.
	DestinationName *string `json:"destination_name" validate:"required"`

	// Topic ID.
	TopicID *string `json:"topic_id" validate:"required"`

	// Topic name.
	TopicName *string `json:"topic_name" validate:"required"`

	Attributes SubscriptionAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// Constants associated with the Subscription.DestinationType property.
// The type of destination.
const (
	SubscriptionDestinationTypeSMTPIBMConst = "smtp_ibm"
	SubscriptionDestinationTypeSmsIBMConst  = "sms_ibm"
	SubscriptionDestinationTypeWebhookConst = "webhook"
)

// SetProperty allows the user to set an arbitrary property on an instance of Subscription
func (o *Subscription) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of Subscription
func (o *Subscription) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of Subscription
func (o *Subscription) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of Subscription
func (o *Subscription) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of Subscription
func (o *Subscription) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.ID != nil {
		m["id"] = o.ID
	}
	if o.Name != nil {
		m["name"] = o.Name
	}
	if o.Description != nil {
		m["description"] = o.Description
	}
	if o.UpdatedAt != nil {
		m["updated_at"] = o.UpdatedAt
	}
	if o.From != nil {
		m["from"] = o.From
	}
	if o.DestinationType != nil {
		m["destination_type"] = o.DestinationType
	}
	if o.DestinationID != nil {
		m["destination_id"] = o.DestinationID
	}
	if o.DestinationName != nil {
		m["destination_name"] = o.DestinationName
	}
	if o.TopicID != nil {
		m["topic_id"] = o.TopicID
	}
	if o.TopicName != nil {
		m["topic_name"] = o.TopicName
	}
	if o.Attributes != nil {
		m["attributes"] = o.Attributes
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscription unmarshals an instance of Subscription from the specified map of raw messages.
func UnmarshalSubscription(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Subscription)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	delete(m, "id")
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	delete(m, "name")
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	delete(m, "description")
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	delete(m, "updated_at")
	err = core.UnmarshalPrimitive(m, "from", &obj.From)
	if err != nil {
		return
	}
	delete(m, "from")
	err = core.UnmarshalPrimitive(m, "destination_type", &obj.DestinationType)
	if err != nil {
		return
	}
	delete(m, "destination_type")
	err = core.UnmarshalPrimitive(m, "destination_id", &obj.DestinationID)
	if err != nil {
		return
	}
	delete(m, "destination_id")
	err = core.UnmarshalPrimitive(m, "destination_name", &obj.DestinationName)
	if err != nil {
		return
	}
	delete(m, "destination_name")
	err = core.UnmarshalPrimitive(m, "topic_id", &obj.TopicID)
	if err != nil {
		return
	}
	delete(m, "topic_id")
	err = core.UnmarshalPrimitive(m, "topic_name", &obj.TopicName)
	if err != nil {
		return
	}
	delete(m, "topic_name")
	err = core.UnmarshalModel(m, "attributes", &obj.Attributes, UnmarshalSubscriptionAttributes)
	if err != nil {
		return
	}
	delete(m, "attributes")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributes : SubscriptionAttributes struct
// Models which "extend" this model:
// - SubscriptionAttributesSmsAttributesResponse
// - SubscriptionAttributesEmailAttributesResponse
// - SubscriptionAttributesWebhookAttributesResponse
type SubscriptionAttributes struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`

	// Decision for Notification Payload to be added.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributes) isaSubscriptionAttributes() bool {
	return true
}

type SubscriptionAttributesIntf interface {
	isaSubscriptionAttributes() bool
	SetProperty(key string, value interface{})
	SetProperties(m map[string]interface{})
	GetProperty(key string) interface{}
	GetProperties() map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributes
func (o *SubscriptionAttributes) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributes
func (o *SubscriptionAttributes) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.SigningEnabled != nil {
		m["signing_enabled"] = o.SigningEnabled
	}
	if o.AddNotificationPayload != nil {
		m["add_notification_payload"] = o.AddNotificationPayload
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributes unmarshals an instance of SubscriptionAttributes from the specified map of raw messages.
func UnmarshalSubscriptionAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributes)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	delete(m, "signing_enabled")
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	delete(m, "add_notification_payload")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributes : SubscriptionCreateAttributes struct
// Models which "extend" this model:
// - SubscriptionCreateAttributesSmsAttributes
// - SubscriptionCreateAttributesEmailAttributes
// - SubscriptionCreateAttributesWebhookAttributes
// - SubscriptionCreateAttributesFcmAttributes
type SubscriptionCreateAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail,omitempty"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name,omitempty"`

	// The email name of From.
	FromName *string `json:"from_name,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`
}

func (*SubscriptionCreateAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

type SubscriptionCreateAttributesIntf interface {
	isaSubscriptionCreateAttributes() bool
}

// UnmarshalSubscriptionCreateAttributes unmarshals an instance of SubscriptionCreateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionList : Subscription list object.
type SubscriptionList struct {
	// Number of subscriptions.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show subscriptions.
	Limit *int64 `json:"limit" validate:"required"`

	// List of subscriptions.
	Subscriptions []SubscriptionListItem `json:"subscriptions" validate:"required"`
}

// UnmarshalSubscriptionList unmarshals an instance of SubscriptionList from the specified map of raw messages.
func UnmarshalSubscriptionList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscriptions", &obj.Subscriptions, UnmarshalSubscriptionListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionListItem : Subscription list item.
type SubscriptionListItem struct {
	// ID of the subscription.
	ID *string `json:"id" validate:"required"`

	// Name of the subscription.
	Name *string `json:"name" validate:"required"`

	// Description of the subscription.
	Description *string `json:"description" validate:"required"`

	// ID of the destination.
	DestinationID *string `json:"destination_id" validate:"required"`

	// Name of the destination.
	DestinationName *string `json:"destination_name,omitempty"`

	// The type of destination.
	DestinationType *string `json:"destination_type" validate:"required"`

	// ID of the topic.
	TopicID *string `json:"topic_id" validate:"required"`

	// Name of the topic.
	TopicName *string `json:"topic_name,omitempty"`

	// Last updated time of the subscription.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// Constants associated with the SubscriptionListItem.DestinationType property.
// The type of destination.
const (
	SubscriptionListItemDestinationTypeSMTPIBMConst = "smtp_ibm"
	SubscriptionListItemDestinationTypeSmsIBMConst  = "sms_ibm"
	SubscriptionListItemDestinationTypeWebhookConst = "webhook"
)

// UnmarshalSubscriptionListItem unmarshals an instance of SubscriptionListItem from the specified map of raw messages.
func UnmarshalSubscriptionListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_id", &obj.DestinationID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_name", &obj.DestinationName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destination_type", &obj.DestinationType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_id", &obj.TopicID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "topic_name", &obj.TopicName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributes : SubscriptionUpdateAttributes struct
// Models which "extend" this model:
// - SubscriptionUpdateAttributesSmsAttributes
// - SubscriptionUpdateAttributesEmailUpdateAttributes
// - SubscriptionUpdateAttributesWebhookAttributes
type SubscriptionUpdateAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to,omitempty"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload,omitempty"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail,omitempty"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name,omitempty"`

	// The email name of From.
	FromName *string `json:"from_name,omitempty"`

	// The email ids invited.
	Invited []string `json:"invited,omitempty"`

	// The email ids.
	Unsubscribed *EmailUpdateAttributesUnsubscribed `json:"unsubscribed,omitempty"`

	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled,omitempty"`
}

func (*SubscriptionUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

type SubscriptionUpdateAttributesIntf interface {
	isaSubscriptionUpdateAttributes() bool
}

// UnmarshalSubscriptionUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "invited", &obj.Invited)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalEmailUpdateAttributesUnsubscribed)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TagsSubscriptionList : Payload describing a tags list request.
type TagsSubscriptionList struct {
	// Total number of tags.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show tags.
	Limit *int64 `json:"limit" validate:"required"`

	// List of tags.
	TagSubscriptions []TagsSubscriptionListItem `json:"tag_subscriptions" validate:"required"`
}

// UnmarshalTagsSubscriptionList unmarshals an instance of TagsSubscriptionList from the specified map of raw messages.
func UnmarshalTagsSubscriptionList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TagsSubscriptionList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "tag_subscriptions", &obj.TagSubscriptions, UnmarshalTagsSubscriptionListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TagsSubscriptionListItem : Tags subscription object.
type TagsSubscriptionListItem struct {
	// Subscription Tag ID.
	ID *string `json:"id" validate:"required"`

	// Unique identifier of the device.
	DeviceID *string `json:"device_id" validate:"required"`

	// The name of the tag its subscribed.
	TagName *string `json:"tag_name" validate:"required"`

	// The user identifier for the the device registration.
	UserID *string `json:"user_id,omitempty"`

	// Updated at.
	UpdatedAt *strfmt.DateTime `json:"updated_at" validate:"required"`
}

// UnmarshalTagsSubscriptionListItem unmarshals an instance of TagsSubscriptionListItem from the specified map of raw messages.
func UnmarshalTagsSubscriptionListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TagsSubscriptionListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "device_id", &obj.DeviceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tag_name", &obj.TagName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_id", &obj.UserID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Topic : Topic object.
type Topic struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Last time the topic was updated.
	UpdatedAt *string `json:"updated_at" validate:"required"`

	// Number of sources.
	SourceCount *int64 `json:"source_count" validate:"required"`

	// List of sources.
	Sources []SourcesListItem `json:"sources" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`

	// List of subscriptions.
	Subscriptions []SubscriptionListItem `json:"subscriptions" validate:"required"`
}

// UnmarshalTopic unmarshals an instance of Topic from the specified map of raw messages.
func UnmarshalTopic(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Topic)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_count", &obj.SourceCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sources", &obj.Sources, UnmarshalSourcesListItem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subscriptions", &obj.Subscriptions, UnmarshalSubscriptionListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicList : Topic list object.
type TopicList struct {
	// Number of topics.
	TotalCount *int64 `json:"total_count" validate:"required"`

	// Current offset.
	Offset *int64 `json:"offset" validate:"required"`

	// limit to show subscriptions.
	Limit *int64 `json:"limit" validate:"required"`

	// List of topics.
	Topics []TopicsListItem `json:"topics" validate:"required"`
}

// UnmarshalTopicList unmarshals an instance of TopicList from the specified map of raw messages.
func UnmarshalTopicList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicList)
	err = core.UnmarshalPrimitive(m, "total_count", &obj.TotalCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "offset", &obj.Offset)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "limit", &obj.Limit)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "topics", &obj.Topics, UnmarshalTopicsListItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicResponse : Topic object.
type TopicResponse struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Last time the topic was updated.
	CreatedAt *string `json:"created_at" validate:"required"`
}

// UnmarshalTopicResponse unmarshals an instance of TopicResponse from the specified map of raw messages.
func UnmarshalTopicResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_at", &obj.CreatedAt)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicUpdateSourcesItem : TopicUpdateSourcesItem struct
type TopicUpdateSourcesItem struct {
	// ID of the source.
	ID *string `json:"id" validate:"required"`

	// List of rules.
	Rules []Rules `json:"rules" validate:"required"`
}

// NewTopicUpdateSourcesItem : Instantiate TopicUpdateSourcesItem (Generic Model Constructor)
func (*EventNotificationsV1) NewTopicUpdateSourcesItem(id string, rules []Rules) (_model *TopicUpdateSourcesItem, err error) {
	_model = &TopicUpdateSourcesItem{
		ID:    core.StringPtr(id),
		Rules: rules,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalTopicUpdateSourcesItem unmarshals an instance of TopicUpdateSourcesItem from the specified map of raw messages.
func UnmarshalTopicUpdateSourcesItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicUpdateSourcesItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "rules", &obj.Rules, UnmarshalRules)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TopicsListItem : Topic list item object.
type TopicsListItem struct {
	// Autogenerated topic ID.
	ID *string `json:"id" validate:"required"`

	// Name of the topic.
	Name *string `json:"name" validate:"required"`

	// Description of the topic.
	Description *string `json:"description" validate:"required"`

	// Number of sources.
	SourceCount *int64 `json:"source_count" validate:"required"`

	// List of source names.
	SourcesNames []string `json:"sources_names" validate:"required"`

	// Number of subscriptions.
	SubscriptionCount *int64 `json:"subscription_count" validate:"required"`
}

// UnmarshalTopicsListItem unmarshals an instance of TopicsListItem from the specified map of raw messages.
func UnmarshalTopicsListItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TopicsListItem)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source_count", &obj.SourceCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sources_names", &obj.SourcesNames)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subscription_count", &obj.SubscriptionCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateDestinationOptions : The UpdateDestination options.
type UpdateDestinationOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Destination.
	ID *string `json:"id" validate:"required,ne="`

	// Destination name.
	Name *string `json:"name,omitempty"`

	// Destination description.
	Description *string `json:"description,omitempty"`

	// Payload describing a destination configuration.
	Config *DestinationConfig `json:"config,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateDestinationOptions : Instantiate UpdateDestinationOptions
func (*EventNotificationsV1) NewUpdateDestinationOptions(instanceID string, id string) *UpdateDestinationOptions {
	return &UpdateDestinationOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateDestinationOptions) SetInstanceID(instanceID string) *UpdateDestinationOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateDestinationOptions) SetID(id string) *UpdateDestinationOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateDestinationOptions) SetName(name string) *UpdateDestinationOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateDestinationOptions) SetDescription(description string) *UpdateDestinationOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetConfig : Allow user to set Config
func (_options *UpdateDestinationOptions) SetConfig(config *DestinationConfig) *UpdateDestinationOptions {
	_options.Config = config
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateDestinationOptions) SetHeaders(param map[string]string) *UpdateDestinationOptions {
	options.Headers = param
	return options
}

// UpdateSubscriptionOptions : The UpdateSubscription options.
type UpdateSubscriptionOptions struct {
	// Unique identifier for IBM Cloud Event Notifications instance.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Unique identifier for Subscription.
	ID *string `json:"id" validate:"required,ne="`

	// Name of the subscription.
	Name *string `json:"name,omitempty"`

	// Description of the subscription.
	Description *string `json:"description,omitempty"`

	Attributes SubscriptionUpdateAttributesIntf `json:"attributes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSubscriptionOptions : Instantiate UpdateSubscriptionOptions
func (*EventNotificationsV1) NewUpdateSubscriptionOptions(instanceID string, id string) *UpdateSubscriptionOptions {
	return &UpdateSubscriptionOptions{
		InstanceID: core.StringPtr(instanceID),
		ID:         core.StringPtr(id),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *UpdateSubscriptionOptions) SetInstanceID(instanceID string) *UpdateSubscriptionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetID : Allow user to set ID
func (_options *UpdateSubscriptionOptions) SetID(id string) *UpdateSubscriptionOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetName : Allow user to set Name
func (_options *UpdateSubscriptionOptions) SetName(name string) *UpdateSubscriptionOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *UpdateSubscriptionOptions) SetDescription(description string) *UpdateSubscriptionOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetAttributes : Allow user to set Attributes
func (_options *UpdateSubscriptionOptions) SetAttributes(attributes SubscriptionUpdateAttributesIntf) *UpdateSubscriptionOptions {
	_options.Attributes = attributes
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSubscriptionOptions) SetHeaders(param map[string]string) *UpdateSubscriptionOptions {
	options.Headers = param
	return options
}

// DestinationConfigParamsFcmDestinationConfig : Payload describing a FCM destination configuration.
// This model "extends" DestinationConfigParams
type DestinationConfigParamsFcmDestinationConfig struct {
	// FCM server_key.
	ServerKey *string `json:"server_key" validate:"required"`

	// FCM sender_id.
	SenderID *string `json:"sender_id" validate:"required"`
}

// NewDestinationConfigParamsFcmDestinationConfig : Instantiate DestinationConfigParamsFcmDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigParamsFcmDestinationConfig(serverKey string, senderID string) (_model *DestinationConfigParamsFcmDestinationConfig, err error) {
	_model = &DestinationConfigParamsFcmDestinationConfig{
		ServerKey: core.StringPtr(serverKey),
		SenderID:  core.StringPtr(senderID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigParamsFcmDestinationConfig) isaDestinationConfigParams() bool {
	return true
}

// UnmarshalDestinationConfigParamsFcmDestinationConfig unmarshals an instance of DestinationConfigParamsFcmDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigParamsFcmDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParamsFcmDestinationConfig)
	err = core.UnmarshalPrimitive(m, "server_key", &obj.ServerKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sender_id", &obj.SenderID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DestinationConfigParamsWebhookDestinationConfig : Payload describing a webhook destination configuration.
// This model "extends" DestinationConfigParams
type DestinationConfigParamsWebhookDestinationConfig struct {
	// URL of webhook.
	URL *string `json:"url" validate:"required"`

	// HTTP method of webhook.
	Verb *string `json:"verb" validate:"required"`

	// Custom headers (Key-Value pair) for webhook call.
	CustomHeaders map[string]string `json:"custom_headers,omitempty"`

	// List of sensitive headers from custom headers.
	SensitiveHeaders []string `json:"sensitive_headers,omitempty"`
}

// Constants associated with the DestinationConfigParamsWebhookDestinationConfig.Verb property.
// HTTP method of webhook.
const (
	DestinationConfigParamsWebhookDestinationConfigVerbGetConst  = "get"
	DestinationConfigParamsWebhookDestinationConfigVerbPostConst = "post"
)

// NewDestinationConfigParamsWebhookDestinationConfig : Instantiate DestinationConfigParamsWebhookDestinationConfig (Generic Model Constructor)
func (*EventNotificationsV1) NewDestinationConfigParamsWebhookDestinationConfig(url string, verb string) (_model *DestinationConfigParamsWebhookDestinationConfig, err error) {
	_model = &DestinationConfigParamsWebhookDestinationConfig{
		URL:  core.StringPtr(url),
		Verb: core.StringPtr(verb),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*DestinationConfigParamsWebhookDestinationConfig) isaDestinationConfigParams() bool {
	return true
}

// UnmarshalDestinationConfigParamsWebhookDestinationConfig unmarshals an instance of DestinationConfigParamsWebhookDestinationConfig from the specified map of raw messages.
func UnmarshalDestinationConfigParamsWebhookDestinationConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DestinationConfigParamsWebhookDestinationConfig)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verb", &obj.Verb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "custom_headers", &obj.CustomHeaders)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sensitive_headers", &obj.SensitiveHeaders)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesEmailAttributesResponse : The attributes reponse for an email destination.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesEmailAttributesResponse struct {

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesEmailAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesEmailAttributesResponse
func (o *SubscriptionAttributesEmailAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesEmailAttributesResponse unmarshals an instance of SubscriptionAttributesEmailAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesEmailAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesEmailAttributesResponse)
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesSmsAttributesResponse : SMS attributes object.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesSmsAttributesResponse struct {

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesSmsAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesSmsAttributesResponse
func (o *SubscriptionAttributesSmsAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesSmsAttributesResponse unmarshals an instance of SubscriptionAttributesSmsAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesSmsAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesSmsAttributesResponse)
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionAttributesWebhookAttributesResponse : The attributes for a webhook notification.
// This model "extends" SubscriptionAttributes
type SubscriptionAttributesWebhookAttributesResponse struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`

	// Decision for Notification Payload to be added.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

func (*SubscriptionAttributesWebhookAttributesResponse) isaSubscriptionAttributes() bool {
	return true
}

// SetProperty allows the user to set an arbitrary property on an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of SubscriptionAttributesWebhookAttributesResponse
func (o *SubscriptionAttributesWebhookAttributesResponse) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.SigningEnabled != nil {
		m["signing_enabled"] = o.SigningEnabled
	}
	if o.AddNotificationPayload != nil {
		m["add_notification_payload"] = o.AddNotificationPayload
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalSubscriptionAttributesWebhookAttributesResponse unmarshals an instance of SubscriptionAttributesWebhookAttributesResponse from the specified map of raw messages.
func UnmarshalSubscriptionAttributesWebhookAttributesResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionAttributesWebhookAttributesResponse)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	delete(m, "signing_enabled")
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	delete(m, "add_notification_payload")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesEmailAttributes : The attributes for an email notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesEmailAttributes struct {
	// The email id string.
	To []string `json:"to" validate:"required"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`
}

// NewSubscriptionCreateAttributesEmailAttributes : Instantiate SubscriptionCreateAttributesEmailAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesEmailAttributes(to []string, addNotificationPayload bool, replyToMail string, replyToName string, fromName string) (_model *SubscriptionCreateAttributesEmailAttributes, err error) {
	_model = &SubscriptionCreateAttributesEmailAttributes{
		To:                     to,
		AddNotificationPayload: core.BoolPtr(addNotificationPayload),
		ReplyToMail:            core.StringPtr(replyToMail),
		ReplyToName:            core.StringPtr(replyToName),
		FromName:               core.StringPtr(fromName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesEmailAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesEmailAttributes unmarshals an instance of SubscriptionCreateAttributesEmailAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesEmailAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesEmailAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesFcmAttributes : The attributes for an FCM notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesFcmAttributes struct {
}

func (*SubscriptionCreateAttributesFcmAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesFcmAttributes unmarshals an instance of SubscriptionCreateAttributesFcmAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesFcmAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesFcmAttributes)
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesSmsAttributes : SMS attributes object.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesSmsAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to" validate:"required"`
}

// NewSubscriptionCreateAttributesSmsAttributes : Instantiate SubscriptionCreateAttributesSmsAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesSmsAttributes(to []string) (_model *SubscriptionCreateAttributesSmsAttributes, err error) {
	_model = &SubscriptionCreateAttributesSmsAttributes{
		To: to,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesSmsAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesSmsAttributes unmarshals an instance of SubscriptionCreateAttributesSmsAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesSmsAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesSmsAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionCreateAttributesWebhookAttributes : The attributes for a webhook notification.
// This model "extends" SubscriptionCreateAttributes
type SubscriptionCreateAttributesWebhookAttributes struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`
}

// NewSubscriptionCreateAttributesWebhookAttributes : Instantiate SubscriptionCreateAttributesWebhookAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionCreateAttributesWebhookAttributes(signingEnabled bool) (_model *SubscriptionCreateAttributesWebhookAttributes, err error) {
	_model = &SubscriptionCreateAttributesWebhookAttributes{
		SigningEnabled: core.BoolPtr(signingEnabled),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionCreateAttributesWebhookAttributes) isaSubscriptionCreateAttributes() bool {
	return true
}

// UnmarshalSubscriptionCreateAttributesWebhookAttributes unmarshals an instance of SubscriptionCreateAttributesWebhookAttributes from the specified map of raw messages.
func UnmarshalSubscriptionCreateAttributesWebhookAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionCreateAttributesWebhookAttributes)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesEmailUpdateAttributes : The attributes for an email notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesEmailUpdateAttributes struct {
	// The email ids.
	To *EmailUpdateAttributesTo `json:"to" validate:"required"`

	// Whether to add the notification payload to the email.
	AddNotificationPayload *bool `json:"add_notification_payload" validate:"required"`

	// The email address to reply to.
	ReplyToMail *string `json:"reply_to_mail" validate:"required"`

	// The email name to reply to.
	ReplyToName *string `json:"reply_to_name" validate:"required"`

	// The email name of From.
	FromName *string `json:"from_name" validate:"required"`

	// The email ids invited.
	Invited []string `json:"invited,omitempty"`

	// The email ids.
	Unsubscribed *EmailUpdateAttributesUnsubscribed `json:"unsubscribed,omitempty"`
}

// NewSubscriptionUpdateAttributesEmailUpdateAttributes : Instantiate SubscriptionUpdateAttributesEmailUpdateAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesEmailUpdateAttributes(to *EmailUpdateAttributesTo, addNotificationPayload bool, replyToMail string, replyToName string, fromName string) (_model *SubscriptionUpdateAttributesEmailUpdateAttributes, err error) {
	_model = &SubscriptionUpdateAttributesEmailUpdateAttributes{
		To:                     to,
		AddNotificationPayload: core.BoolPtr(addNotificationPayload),
		ReplyToMail:            core.StringPtr(replyToMail),
		ReplyToName:            core.StringPtr(replyToName),
		FromName:               core.StringPtr(fromName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesEmailUpdateAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesEmailUpdateAttributes unmarshals an instance of SubscriptionUpdateAttributesEmailUpdateAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesEmailUpdateAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesEmailUpdateAttributes)
	err = core.UnmarshalModel(m, "to", &obj.To, UnmarshalEmailUpdateAttributesTo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "add_notification_payload", &obj.AddNotificationPayload)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_mail", &obj.ReplyToMail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reply_to_name", &obj.ReplyToName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "from_name", &obj.FromName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "invited", &obj.Invited)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsubscribed", &obj.Unsubscribed, UnmarshalEmailUpdateAttributesUnsubscribed)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesSmsAttributes : SMS attributes object.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesSmsAttributes struct {
	// The phone number to send the SMS to.
	To []string `json:"to" validate:"required"`
}

// NewSubscriptionUpdateAttributesSmsAttributes : Instantiate SubscriptionUpdateAttributesSmsAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesSmsAttributes(to []string) (_model *SubscriptionUpdateAttributesSmsAttributes, err error) {
	_model = &SubscriptionUpdateAttributesSmsAttributes{
		To: to,
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesSmsAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesSmsAttributes unmarshals an instance of SubscriptionUpdateAttributesSmsAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesSmsAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesSmsAttributes)
	err = core.UnmarshalPrimitive(m, "to", &obj.To)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionUpdateAttributesWebhookAttributes : The attributes for a webhook notification.
// This model "extends" SubscriptionUpdateAttributes
type SubscriptionUpdateAttributesWebhookAttributes struct {
	// Signing webhook attributes.
	SigningEnabled *bool `json:"signing_enabled" validate:"required"`
}

// NewSubscriptionUpdateAttributesWebhookAttributes : Instantiate SubscriptionUpdateAttributesWebhookAttributes (Generic Model Constructor)
func (*EventNotificationsV1) NewSubscriptionUpdateAttributesWebhookAttributes(signingEnabled bool) (_model *SubscriptionUpdateAttributesWebhookAttributes, err error) {
	_model = &SubscriptionUpdateAttributesWebhookAttributes{
		SigningEnabled: core.BoolPtr(signingEnabled),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

func (*SubscriptionUpdateAttributesWebhookAttributes) isaSubscriptionUpdateAttributes() bool {
	return true
}

// UnmarshalSubscriptionUpdateAttributesWebhookAttributes unmarshals an instance of SubscriptionUpdateAttributesWebhookAttributes from the specified map of raw messages.
func UnmarshalSubscriptionUpdateAttributesWebhookAttributes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionUpdateAttributesWebhookAttributes)
	err = core.UnmarshalPrimitive(m, "signing_enabled", &obj.SigningEnabled)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}
